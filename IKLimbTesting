using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class IKTesting : MonoBehaviour
{
    public enum interpolationType{ bezier, linear};
    public interpolationType lineType;

    public int boneLength; //amount of bones
    public Transform targetTransform;
    public Transform baseTransform;

    [Header("Curve Variables")]
    private Vector3 frontCurve;
    public Vector3 frontCurveEdit;
    private Vector3 backCurve;
    public Vector3 backCurveEdit;

    public Transform[] boneTransform;

    [Header("Bone Distances")]
    float extendedDistanceTotal;
    float[] extendedDistaceForBones;
    float totalDistance;
    float[] boneDistance;

    [Header("Curve Interpolation")]
    public int Iterations = 25;
    public float[] arcDistance;
    float arcDistanceTotal;


    Quaternion[] boneRotation;

    Vector3[] bonePositionL;
    Vector3[] bonePositionG;

    private void Start()
    {
        // get array length here
        boneTransform = new Transform[boneLength];
        extendedDistaceForBones = new float[boneLength];
        boneRotation = new Quaternion[boneLength];
        bonePositionL = new Vector3[boneLength];
        bonePositionG = new Vector3[boneLength];

        arcDistance = new float[Iterations+1];
        arcDistance[0] = 0;

        int i = 0;
        Transform recurseBoneTransform; //could make an array of base transforms for multiple limbs

        //initialize array values here
        for (i = 0; i < boneLength; i++)
        {
            if (i == 0)
            {
                boneTransform.SetValue(baseTransform, 0);
                extendedDistaceForBones.SetValue(0, 0);
            }

            if (i < boneLength - 1)
            {
                recurseBoneTransform = boneTransform[i].GetChild(0); //connecting bone needs to be first in position
                boneTransform.SetValue(recurseBoneTransform, i + 1);
            }

            boneRotation.SetValue(boneTransform[i].localRotation, i);
            bonePositionL.SetValue(boneTransform[i].localPosition, i);
            bonePositionG.SetValue(boneTransform[i].position, i);

            if (i > 0)
            {
                Vector3 initialposition = boneTransform[i - 1].position;
                Vector3 finalPosition = boneTransform[i].position;
                float distance = Vector3.Distance(initialposition, finalPosition);
                extendedDistaceForBones.SetValue(distance, i);

                extendedDistanceTotal += distance;
            }
        }
    }
    private void Update()
    {
        BezierCalculation();
        //to Remove just to avoid null errors, should be given by call
        frontCurve = baseTransform.localPosition + frontCurveEdit;
        backCurve = targetTransform.localPosition + backCurveEdit;

    }
    /*get line from target to position, then isolate by rotation degrees of freedom, 
     * rotation should be where vector target is pointing
     * need actual position with bones that shouldnt be attached
     * normalize target distance if above max distance
     */
    public void BezierCalculation()
    {
        int iterationI = 0;
        int boneI = 0;
        arcDistanceTotal = 0;
        float arcDistanceCumulative = 0;

        Vector3[] finishedPosition = new Vector3[boneLength];

        //layer 1 bezier curve cubic
        Vector3 position1 = baseTransform.position;
        Vector3 position2 = frontCurve;  // these need to be decided through a script
        Vector3 position3 = backCurve;   //
        Vector3 position4 = targetTransform.position;
        //layer 2
        Vector3 positionA;
        Vector3 positionB;
        Vector3 positionC;
        //layer 3
        Vector3 positionD;
        Vector3 positionE;
        //layer 4
        Vector3[] BezierCurvePos = new Vector3[Iterations];
        BezierCurvePos.SetValue(Vector3.zero, 0);
        //T is the %completion of the curve
        float[] t = new float[Iterations];
        //firstArrayValue should be 0

        //iterations
        for (iterationI = 1; iterationI <= Iterations - 1; iterationI++)
        {
            #region bezier calculations
            t.SetValue((float)iterationI / (float)Iterations, iterationI);

            positionA = Vector3.Lerp(position1, position2, t[iterationI]);
            positionB = Vector3.Lerp(position2, position3, t[iterationI]);
            positionC = Vector3.Lerp(position3, position4, t[iterationI]);

            positionD = Vector3.Lerp(positionA, positionB, t[iterationI]);
            positionE = Vector3.Lerp(positionB, positionC, t[iterationI]);

            BezierCurvePos.SetValue(Vector3.Lerp(positionD, positionE, t[iterationI]), iterationI);
            arcDistanceCumulative += Vector3.Distance(BezierCurvePos[iterationI - 1], BezierCurvePos[iterationI]);
            arcDistance.SetValue(arcDistanceCumulative, iterationI);
            #endregion
        }
        for(boneI = 1; boneI <= boneLength; boneI++)
        {

        }
        
    }
    public void MoveRotation()
    {

    }


}
