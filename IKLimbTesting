using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class IKTesting : MonoBehaviour
{
    public enum InterpolationType { bezier, linear };
    public InterpolationType lineType;

    public int boneLength; //amount of bones
    public Transform targetTransform;
    public Transform baseTransform;

    [Header("Curve Variables")]
    private Vector3 frontCurve;
    public Vector3 frontCurveEdit;
    private Vector3 backCurve;
    public Vector3 backCurveEdit;

    public Transform[] boneTransform;

    [Header("Bone Distances")]
    float extendedDistanceTotal;
    public float[] extendedDistaceForBones;
    float totalDistance;
    public float[] boneDistance;
    public float[] boneDistancePreCal;

    [Header("Curve Interpolation")]
    public int Iterations = 25;
    public float[] arcDistance;
    public float arcDistanceTotal;


    Quaternion[] boneRotation;

    private void Start()
    {
        // get array length here
        boneTransform = new Transform[boneLength];
        extendedDistaceForBones = new float[boneLength];
        boneRotation = new Quaternion[boneLength];
        boneDistance = new float[boneLength];
        boneDistancePreCal = new float[boneLength];

        arcDistance = new float[Iterations];
        arcDistance[0] = 0;

        int i = 0;
        Transform recurseBoneTransform; //could make an array of base transforms for multiple limbs

        //initialize array values here
        for (i = 0; i < boneLength; i++)
        {
            if (i == 0)
            {
                boneTransform.SetValue(baseTransform, 0);
                extendedDistaceForBones.SetValue(0, 0);
            }

            if (i < boneLength - 1)
            {
                recurseBoneTransform = boneTransform[i].GetChild(0); //connecting bone needs to be first in position
                boneTransform.SetValue(recurseBoneTransform, i + 1);
            }

            boneRotation.SetValue(boneTransform[i].localRotation, i);

            if (i > 0)
            {
                Vector3 initialposition = boneTransform[i - 1].position;
                Vector3 finalPosition = boneTransform[i].position;
                float distance = Vector3.Distance(initialposition, finalPosition);
                extendedDistaceForBones.SetValue(distance, i);

                extendedDistanceTotal += distance;
            }
        }
    }
    private void Update()
    {
        BezierLookUpTable();
        //to Remove just to avoid null errors, should be given by call
        frontCurve = baseTransform.localPosition + frontCurveEdit;
        backCurve = targetTransform.localPosition + backCurveEdit;

    }
    /*get line from target to position, then isolate by rotation degrees of freedom, 
     * rotation should be where vector target is pointing
     * need actual position with bones that shouldnt be attached
     * normalize target distance if above max distance
     */
    public void BezierLookUpTable()
    { 
        //setting couters to 0
        int iterationI;
        float arcDistanceCumulative = 0;

        float[] t = new float[Iterations];

        Vector3[] finishedPosition = new Vector3[boneLength];
        Vector3[] BezierCurvePos = new Vector3[Iterations];
        BezierCurvePos.SetValue(Vector3.zero, 0); // first array value should be 0
        finishedPosition.SetValue(Vector3.zero, 0);

        //iterations
        for (iterationI = 1; iterationI < Iterations; iterationI++)
        {
            t.SetValue((float)iterationI / (float)Iterations, iterationI);

            BezierCurvePos.SetValue(BezierCurve(t[iterationI]), iterationI);//gets value of curve from t value

            //calculates arc distance from T values
            arcDistanceCumulative += Vector3.Distance(BezierCurvePos[iterationI - 1], BezierCurvePos[iterationI]);
            arcDistance.SetValue(arcDistanceCumulative, iterationI);
            arcDistanceTotal = arcDistance[iterationI] + arcDistance[1];
        }

        Debug.Log("fuckyou");

        if(iterationI == 0)
        {
            Debug.Log("fuck you if statment");
            BezierDistanceCalculation(t);
            
        }
    }
    public void BezierDistanceCalculation(float[] t)
    {
        int boneI = 0;
        int distanceint = 0;
        float boneDistanceCumulative = 0;

        float[] T = new float[boneLength];

        for (boneI = 0; boneI <= boneLength; boneI++)
        {
            Debug.Log("fuck you");
            boneDistanceCumulative = extendedDistaceForBones[boneI];
            float desiredDistance = (boneDistanceCumulative / extendedDistanceTotal)*arcDistanceTotal;

            boneDistancePreCal[boneI] = boneDistanceCumulative;

            while (desiredDistance < t[distanceint])
            {
                distanceint++;
            }

            T.SetValue(t[distanceint], boneI);
            boneDistance.SetValue(T[boneI], boneI);
            boneTransform[boneI].position = BezierCurve(T[boneI]);
        }
    }
    public Vector3 BezierCurve(float Tinput)
    {
        //layer 1 bezier curve cubic
        Vector3 position1 = baseTransform.position;
        Vector3 position2 = frontCurve;
        Vector3 position3 = backCurve;
        Vector3 position4 = targetTransform.position;
        //layer 2
        Vector3 positionA;
        Vector3 positionB;
        Vector3 positionC;
        //layer 3
        Vector3 positionD;
        Vector3 positionE;
        //layer 4
        Vector3 bezierOutput;

        positionA = Vector3.Lerp(position1, position2, Tinput);
        positionB = Vector3.Lerp(position2, position3, Tinput);
        positionC = Vector3.Lerp(position3, position4, Tinput);

        positionD = Vector3.Lerp(positionA, positionB, Tinput);
        positionE = Vector3.Lerp(positionB, positionC, Tinput);

        bezierOutput = Vector3.Lerp(positionD, positionE, Tinput);

        return bezierOutput;
    }
}
